{
  "version": 3,
  "sources": ["../../../../../../node_modules/three/examples/jsm/loaders/PLYLoader.js"],
  "sourcesContent": ["import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, Color, SRGBColorSpace } from 'three';\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tconst loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n * Custom properties outside of the defaults for position, uv, normal\n * and color attributes can be added using the setCustomPropertyNameMapping method.\n * For example, the following maps the element properties “custom_property_a”\n * and “custom_property_b” to an attribute “customAttribute” with an item size of 2.\n * Attribute item sizes are set from the number of element properties in the property array.\n *\n * loader.setCustomPropertyNameMapping( {\n *\tcustomAttribute: ['custom_property_a', 'custom_property_b'],\n * } );\n *\n */\n\nconst _color = new Color();\nclass PLYLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.propertyNameMapping = {};\n    this.customPropertyMapping = {};\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping;\n  }\n  setCustomPropertyNameMapping(mapping) {\n    this.customPropertyMapping = mapping;\n  }\n  parse(data) {\n    function parseHeader(data, headerLength = 0) {\n      const patternHeader = /^ply([\\s\\S]*)end_header(\\r\\n|\\r|\\n)/;\n      let headerText = '';\n      const result = patternHeader.exec(data);\n      if (result !== null) {\n        headerText = result[1];\n      }\n      const header = {\n        comments: [],\n        elements: [],\n        headerLength: headerLength,\n        objInfo: ''\n      };\n      const lines = headerText.split(/\\r\\n|\\r|\\n/);\n      let currentElement;\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        const property = {\n          type: propertValues[0]\n        };\n        if (property.type === 'list') {\n          property.name = propertValues[3];\n          property.countType = propertValues[1];\n          property.itemType = propertValues[2];\n        } else {\n          property.name = propertValues[1];\n        }\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n        return property;\n      }\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === '') continue;\n        const lineValues = line.split(/\\s+/);\n        const lineType = lineValues.shift();\n        line = lineValues.join(' ');\n        switch (lineType) {\n          case 'format':\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n          case 'comment':\n            header.comments.push(line);\n            break;\n          case 'element':\n            if (currentElement !== undefined) {\n              header.elements.push(currentElement);\n            }\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n          case 'property':\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n          case 'obj_info':\n            header.objInfo = line;\n            break;\n          default:\n            console.log('unhandled', lineType, lineValues);\n        }\n      }\n      if (currentElement !== undefined) {\n        header.elements.push(currentElement);\n      }\n      return header;\n    }\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n          return parseInt(n);\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n          return parseFloat(n);\n      }\n    }\n    function parseASCIIElement(properties, tokens) {\n      const element = {};\n      for (let i = 0; i < properties.length; i++) {\n        if (tokens.empty()) return null;\n        if (properties[i].type === 'list') {\n          const list = [];\n          const n = parseASCIINumber(tokens.next(), properties[i].countType);\n          for (let j = 0; j < n; j++) {\n            if (tokens.empty()) return null;\n            list.push(parseASCIINumber(tokens.next(), properties[i].itemType));\n          }\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(tokens.next(), properties[i].type);\n        }\n      }\n      return element;\n    }\n    function createBuffer() {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: [],\n        faceVertexColors: []\n      };\n      for (const customProperty of Object.keys(scope.customPropertyMapping)) {\n        buffer[customProperty] = [];\n      }\n      return buffer;\n    }\n    function mapElementAttributes(properties) {\n      const elementNames = properties.map(property => {\n        return property.name;\n      });\n      function findAttrName(names) {\n        for (let i = 0, l = names.length; i < l; i++) {\n          const name = names[i];\n          if (elementNames.includes(name)) return name;\n        }\n        return null;\n      }\n      return {\n        attrX: findAttrName(['x', 'px', 'posx']) || 'x',\n        attrY: findAttrName(['y', 'py', 'posy']) || 'y',\n        attrZ: findAttrName(['z', 'pz', 'posz']) || 'z',\n        attrNX: findAttrName(['nx', 'normalx']),\n        attrNY: findAttrName(['ny', 'normaly']),\n        attrNZ: findAttrName(['nz', 'normalz']),\n        attrS: findAttrName(['s', 'u', 'texture_u', 'tx']),\n        attrT: findAttrName(['t', 'v', 'texture_v', 'ty']),\n        attrR: findAttrName(['red', 'diffuse_red', 'r', 'diffuse_r']),\n        attrG: findAttrName(['green', 'diffuse_green', 'g', 'diffuse_g']),\n        attrB: findAttrName(['blue', 'diffuse_blue', 'b', 'diffuse_b'])\n      };\n    }\n    function parseASCII(data, header) {\n      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n      const buffer = createBuffer();\n      const patternBody = /end_header\\s+(\\S[\\s\\S]*\\S|\\S)\\s*$/;\n      let body, matches;\n      if ((matches = patternBody.exec(data)) !== null) {\n        body = matches[1].split(/\\s+/);\n      } else {\n        body = [];\n      }\n      const tokens = new ArrayStream(body);\n      loop: for (let i = 0; i < header.elements.length; i++) {\n        const elementDesc = header.elements[i];\n        const attributeMap = mapElementAttributes(elementDesc.properties);\n        for (let j = 0; j < elementDesc.count; j++) {\n          const element = parseASCIIElement(elementDesc.properties, tokens);\n          if (!element) break loop;\n          handleElement(buffer, elementDesc.name, element, attributeMap);\n        }\n      }\n      return postProcess(buffer);\n    }\n    function postProcess(buffer) {\n      let geometry = new BufferGeometry();\n\n      // mandatory buffer data\n\n      if (buffer.indices.length > 0) {\n        geometry.setIndex(buffer.indices);\n      }\n      geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3));\n\n      // optional buffer data\n\n      if (buffer.normals.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3));\n      }\n      if (buffer.uvs.length > 0) {\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2));\n      }\n      if (buffer.colors.length > 0) {\n        geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3));\n      }\n      if (buffer.faceVertexUvs.length > 0 || buffer.faceVertexColors.length > 0) {\n        geometry = geometry.toNonIndexed();\n        if (buffer.faceVertexUvs.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n        if (buffer.faceVertexColors.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(buffer.faceVertexColors, 3));\n      }\n\n      // custom buffer data\n\n      for (const customProperty of Object.keys(scope.customPropertyMapping)) {\n        if (buffer[customProperty].length > 0) {\n          geometry.setAttribute(customProperty, new Float32BufferAttribute(buffer[customProperty], scope.customPropertyMapping[customProperty].length));\n        }\n      }\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n    function handleElement(buffer, elementName, element, cacheEntry) {\n      if (elementName === 'vertex') {\n        buffer.vertices.push(element[cacheEntry.attrX], element[cacheEntry.attrY], element[cacheEntry.attrZ]);\n        if (cacheEntry.attrNX !== null && cacheEntry.attrNY !== null && cacheEntry.attrNZ !== null) {\n          buffer.normals.push(element[cacheEntry.attrNX], element[cacheEntry.attrNY], element[cacheEntry.attrNZ]);\n        }\n        if (cacheEntry.attrS !== null && cacheEntry.attrT !== null) {\n          buffer.uvs.push(element[cacheEntry.attrS], element[cacheEntry.attrT]);\n        }\n        if (cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null) {\n          _color.setRGB(element[cacheEntry.attrR] / 255.0, element[cacheEntry.attrG] / 255.0, element[cacheEntry.attrB] / 255.0, SRGBColorSpace);\n          buffer.colors.push(_color.r, _color.g, _color.b);\n        }\n        for (const customProperty of Object.keys(scope.customPropertyMapping)) {\n          for (const elementProperty of scope.customPropertyMapping[customProperty]) {\n            buffer[customProperty].push(element[elementProperty]);\n          }\n        }\n      } else if (elementName === 'face') {\n        const vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n        const texcoord = element.texcoord;\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n\n        // face colors\n\n        if (cacheEntry.attrR !== null && cacheEntry.attrG !== null && cacheEntry.attrB !== null) {\n          _color.setRGB(element[cacheEntry.attrR] / 255.0, element[cacheEntry.attrG] / 255.0, element[cacheEntry.attrB] / 255.0, SRGBColorSpace);\n          buffer.faceVertexColors.push(_color.r, _color.g, _color.b);\n          buffer.faceVertexColors.push(_color.r, _color.g, _color.b);\n          buffer.faceVertexColors.push(_color.r, _color.g, _color.b);\n        }\n      }\n    }\n    function binaryReadElement(at, properties) {\n      const element = {};\n      let read = 0;\n      for (let i = 0; i < properties.length; i++) {\n        const property = properties[i];\n        const valueReader = property.valueReader;\n        if (property.type === 'list') {\n          const list = [];\n          const n = property.countReader.read(at + read);\n          read += property.countReader.size;\n          for (let j = 0; j < n; j++) {\n            list.push(valueReader.read(at + read));\n            read += valueReader.size;\n          }\n          element[property.name] = list;\n        } else {\n          element[property.name] = valueReader.read(at + read);\n          read += valueReader.size;\n        }\n      }\n      return [element, read];\n    }\n    function setPropertyBinaryReaders(properties, body, little_endian) {\n      function getBinaryReader(dataview, type, little_endian) {\n        switch (type) {\n          // corespondences for non-specific length types here match rply:\n          case 'int8':\n          case 'char':\n            return {\n              read: at => {\n                return dataview.getInt8(at);\n              },\n              size: 1\n            };\n          case 'uint8':\n          case 'uchar':\n            return {\n              read: at => {\n                return dataview.getUint8(at);\n              },\n              size: 1\n            };\n          case 'int16':\n          case 'short':\n            return {\n              read: at => {\n                return dataview.getInt16(at, little_endian);\n              },\n              size: 2\n            };\n          case 'uint16':\n          case 'ushort':\n            return {\n              read: at => {\n                return dataview.getUint16(at, little_endian);\n              },\n              size: 2\n            };\n          case 'int32':\n          case 'int':\n            return {\n              read: at => {\n                return dataview.getInt32(at, little_endian);\n              },\n              size: 4\n            };\n          case 'uint32':\n          case 'uint':\n            return {\n              read: at => {\n                return dataview.getUint32(at, little_endian);\n              },\n              size: 4\n            };\n          case 'float32':\n          case 'float':\n            return {\n              read: at => {\n                return dataview.getFloat32(at, little_endian);\n              },\n              size: 4\n            };\n          case 'float64':\n          case 'double':\n            return {\n              read: at => {\n                return dataview.getFloat64(at, little_endian);\n              },\n              size: 8\n            };\n        }\n      }\n      for (let i = 0, l = properties.length; i < l; i++) {\n        const property = properties[i];\n        if (property.type === 'list') {\n          property.countReader = getBinaryReader(body, property.countType, little_endian);\n          property.valueReader = getBinaryReader(body, property.itemType, little_endian);\n        } else {\n          property.valueReader = getBinaryReader(body, property.type, little_endian);\n        }\n      }\n    }\n    function parseBinary(data, header) {\n      const buffer = createBuffer();\n      const little_endian = header.format === 'binary_little_endian';\n      const body = new DataView(data, header.headerLength);\n      let result,\n        loc = 0;\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        const elementDesc = header.elements[currentElement];\n        const properties = elementDesc.properties;\n        const attributeMap = mapElementAttributes(properties);\n        setPropertyBinaryReaders(properties, body, little_endian);\n        for (let currentElementCount = 0; currentElementCount < elementDesc.count; currentElementCount++) {\n          result = binaryReadElement(loc, properties);\n          loc += result[1];\n          const element = result[0];\n          handleElement(buffer, elementDesc.name, element, attributeMap);\n        }\n      }\n      return postProcess(buffer);\n    }\n    function extractHeaderText(bytes) {\n      let i = 0;\n      let cont = true;\n      let line = '';\n      const lines = [];\n      const startLine = new TextDecoder().decode(bytes.subarray(0, 5));\n      const hasCRNL = /^ply\\r\\n/.test(startLine);\n      do {\n        const c = String.fromCharCode(bytes[i++]);\n        if (c !== '\\n' && c !== '\\r') {\n          line += c;\n        } else {\n          if (line === 'end_header') cont = false;\n          if (line !== '') {\n            lines.push(line);\n            line = '';\n          }\n        }\n      } while (cont && i < bytes.length);\n\n      // ascii section using \\r\\n as line endings\n      if (hasCRNL === true) i++;\n      return {\n        headerText: lines.join('\\r') + '\\r',\n        headerLength: i\n      };\n    }\n\n    //\n\n    let geometry;\n    const scope = this;\n    if (data instanceof ArrayBuffer) {\n      const bytes = new Uint8Array(data);\n      const {\n        headerText,\n        headerLength\n      } = extractHeaderText(bytes);\n      const header = parseHeader(headerText, headerLength);\n      if (header.format === 'ascii') {\n        const text = new TextDecoder().decode(bytes);\n        geometry = parseASCII(text, header);\n      } else {\n        geometry = parseBinary(data, header);\n      }\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n    return geometry;\n  }\n}\nclass ArrayStream {\n  constructor(arr) {\n    this.arr = arr;\n    this.i = 0;\n  }\n  empty() {\n    return this.i >= this.arr.length;\n  }\n  next() {\n    return this.arr[this.i++];\n  }\n}\nexport { PLYLoader };"],
  "mappings": "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",
  "names": ["data", "geometry", "little_endian"]
}
